<!doctype html>
<html lang="nb">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>S√∏k produkter - Mat Sjekk</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <main class="container">
    <div class="quick-links">
      <a href="index.html" class="btn">üè† Matsjekk.com</a>
      <a href="index.html#news" class="btn">üì∞ Nyheter</a>
      <a href="gardsbutikker.html" class="btn">üè¨ G√•rdsbutikker</a>
    </div>
    <h1>S√∏k produkt</h1>
    <p>S√∏k etter EAN (strekkode) eller produktnavn. Resultatet bruker samme risikologikk som appen (Bovaer, insektmel, GMO-fiskef√¥r).</p>

    <div class="search-box">
      <input id="query" placeholder="Skriv EAN eller produktnavn" />
      <select id="country">
        <option value="NO">Norge</option>
        <option value="SE">Sverige</option>
        <option value="DK">Danmark</option>
      </select>
      <select id="engine">
        <option value="off">OpenFoodFacts</option>
        <option value="google">Google-s√∏k</option>
        <option value="ai">AI-s√∏k</option>
      </select>
      <button id="search">S√∏k</button>
      <button id="searchGoogle" type="button">Google n√•</button>
      <button id="searchAi" type="button">AI n√•</button>
    </div>

    <div id="result"></div>
  </main>

  <script>
  async function loadRisk() {
    const res = await fetch('data/risk.json');
    return res.json();
  }

  function toTextList(value) {
    if (Array.isArray(value)) return value.join(' ');
    if (typeof value === 'string') return value;
    return '';
  }

  function countryLabel(code) {
    const labels = {
      NO: 'Norge',
      SE: 'Sverige',
      DK: 'Danmark',
    };
    return labels[code] || code;
  }

  function openExternalSearch(engine, query, country) {
    const baseQuery = `${query} matvare ${countryLabel(country)} Bovaer GMO insektmel`;
    const encoded = encodeURIComponent(baseQuery.trim());
    const url = engine === 'ai'
      ? `https://www.perplexity.ai/search/new?q=${encoded}`
      : `https://www.google.com/search?q=${encoded}`;
    window.open(url, '_blank', 'noopener');
  }

  function classify(product, riskData, country) {
    const brand = (product.brands || product.brand || '').toLowerCase();
    const labels = toTextList(product.labels || product.labels_tags).toLowerCase();
    const ingredients = (product.ingredients_text || product.ingredients_text_en || '').toLowerCase();

    const cdata = riskData[country] || riskData['NO'];

    // Organic check
    const organicKeywords = cdata.organic_keywords || [];
    const isOrganic = organicKeywords.some(k => (labels + ' ' + ingredients).includes(k.toLowerCase()));

    // Bovaer brand checks
    const brandNormalized = brand.replaceAll(/[^a-z0-9√•√∏√¶√§√∂√º√©√®]/g,'');
    const bRed = (cdata.bovaer_red || []).map(b=>b.toLowerCase());
    const bYellow = (cdata.bovaer_yellow || []).map(b=>b.toLowerCase());
    const isBovaerRed = bRed.some(b => brand.includes(b) || brandNormalized.includes(b.replace(/[^a-z0-9]/g,'')));
    const isBovaerYellow = bYellow.some(b => brand.includes(b));

    // Insect meal check (simple keywords)
    const insectKeywords = ['insect','insektsmel','insektsprotein','mealworm','meal worm','black soldier fly','insektsmel'];
    const hasInsect = insectKeywords.some(k => ingredients.includes(k) || labels.includes(k));

    return {
      isOrganic, isBovaerRed, isBovaerYellow, hasInsect
    };
  }

  async function searchProduct(query, country, riskData) {
    const resultEl = document.getElementById('result');
    resultEl.innerHTML = '<p>Laster‚Ä¶</p>';
    // If query looks like digits (EAN), use product API
    if (/^\d{8,13}$/.test(query.trim())) {
      const url = `https://world.openfoodfacts.org/api/v2/product/${query}.json`;
      try {
        const r = await fetch(url);
        const j = await r.json();
        if (j.status === 1) {
          const p = j.product;
          const c = classify(p, riskData, country);
          resultEl.innerHTML = renderProduct(p, c);
        } else {
          resultEl.innerHTML = '<p>Produkt ikke funnet.</p>';
        }
      } catch (e) { resultEl.innerHTML = '<p>Feil under foresp√∏rsel.</p>'; }
      return;
    }

    // Otherwise use search endpoint
    const params = new URLSearchParams({search_terms: query, search_simple: '1', json: '1', page_size: '10'});
    const url = `https://world.openfoodfacts.org/cgi/search.pl?${params.toString()}`;
    try {
      const r = await fetch(url);
      const j = await r.json();
      if (!j.products || j.products.length === 0) { resultEl.innerHTML = '<p>Ingen treff.</p>'; return; }
      resultEl.innerHTML = j.products.map(p=>{
        const c = classify(p, riskData, country);
        return `<div class="search-hit">${renderProduct(p,c)}</div>`;
      }).join('\n');
    } catch (e) { resultEl.innerHTML = '<p>Feil under s√∏k.</p>'; }
  }

  function renderProduct(p, c) {
    const title = p.product_name || p.generic_name || 'Uten navn';
    const brand = p.brands || p.brands_tags && p.brands_tags[0] || 'Ukjent';
    const ean = p.code || '';
    const labels = Array.isArray(p.labels_tags)
      ? p.labels_tags.join(', ')
      : (typeof p.labels === 'string' ? p.labels : '');
    const notes = [];
    if (c.isOrganic) notes.push('√òkologisk (merking funnet)');
    if (c.isBovaerRed) notes.push('Bovaer: h√∏y risiko (produsent i r√∏d liste)');
    else if (c.isBovaerYellow) notes.push('Bovaer: moderat risiko (produsent i gul liste)');
    if (c.hasInsect) notes.push('Insektmel: indikasjon i ingredienslisten');
    return `
      <div class="product">
        <h3>${escapeHtml(title)}</h3>
        <p><strong>Merke:</strong> ${escapeHtml(brand)} ‚Ä¢ <strong>EAN:</strong> ${escapeHtml(ean)}</p>
        <p><strong>Merkelapper:</strong> ${escapeHtml(labels)}</p>
        <p><strong>Vurdering:</strong> ${notes.length ? notes.join(' ‚Ä¢ ') : 'Ingen risiko funnet basert p√• tilgjengelig data'}</p>
        <p><a href="https://world.openfoodfacts.org/product/${ean}" target="_blank">√Öpne i OpenFoodFacts</a></p>
      </div>`;
  }

  function escapeHtml(s){ if(!s) return ''; return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

  document.getElementById('search').addEventListener('click', async ()=>{
    const q = document.getElementById('query').value.trim();
    const country = document.getElementById('country').value;
    const engine = document.getElementById('engine').value;
    if (!q) return;
    if (engine === 'google' || engine === 'ai') {
      openExternalSearch(engine, q, country);
      return;
    }
    const riskData = await loadRisk();
    await searchProduct(q,country,riskData);
  });

  document.getElementById('searchGoogle').addEventListener('click', () => {
    const q = document.getElementById('query').value.trim();
    const country = document.getElementById('country').value;
    if (!q) return;
    openExternalSearch('google', q, country);
  });

  document.getElementById('searchAi').addEventListener('click', () => {
    const q = document.getElementById('query').value.trim();
    const country = document.getElementById('country').value;
    if (!q) return;
    openExternalSearch('ai', q, country);
  });
  </script>
</body>
</html>
